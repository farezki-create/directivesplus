
import { CodeGenerationService } from "./codeGeneration";
import { ValidationService } from "./validation";
import { DiagnosticService } from "./diagnostic";
import { CodeManagementService } from "./codeManagement";
import { AnonymousValidationService } from "./anonymousValidation";
import type { 
  PersonalInfo, 
  AccessCodeOptions, 
  AccessValidationResult, 
  CodeGenerationResult
} from "@/types/accessCode";

/**
 * Service unifi√© pour la gestion des codes d'acc√®s
 * Orchestration des diff√©rents services sp√©cialis√©s
 */
export class AccessCodeService {
  
  // ============ G√âN√âRATION DE CODES ============
  
  /**
   * G√©n√®re un code fixe reproductible bas√© sur l'ID utilisateur
   */
  static generateFixedCode(userId: string): string {
    return CodeGenerationService.generateFixedCode(userId);
  }

  /**
   * G√©n√®re un code temporaire unique
   */
  static generateTemporaryCode(): string {
    return CodeGenerationService.generateTemporaryCode();
  }

  // ============ DIAGNOSTIC ET DONN√âES DE TEST ============

  /**
   * Cr√©e un utilisateur de test pour valider le syst√®me
   */
  static async createTestUser(): Promise<{ userId: string; fixedCode: string }> {
    return DiagnosticService.createTestUser();
  }

  /**
   * Effectue un diagnostic complet du syst√®me
   */
  static async diagnosticSystem(personalInfo: PersonalInfo): Promise<any> {
    return DiagnosticService.diagnosticSystem(personalInfo);
  }

  // ============ CR√âATION DE CODES D'ACC√àS ============

  /**
   * Cr√©e un code d'acc√®s temporaire pour un utilisateur
   */
  static async createTemporaryCode(
    userId: string, 
    options: AccessCodeOptions = {}
  ): Promise<CodeGenerationResult> {
    return CodeManagementService.createTemporaryCode(userId, options);
  }

  // ============ VALIDATION DE CODES ============

  /**
   * Valide un code d'acc√®s (temporaire ou fixe) avec fallback anonyme
   */
  static async validateCode(
    accessCode: string,
    personalInfo?: PersonalInfo
  ): Promise<AccessValidationResult> {
    try {
      console.log("=== VALIDATION CODE D'ACC√àS AM√âLIOR√âE ===");
      console.log("Code:", accessCode, "Infos:", personalInfo);

      // 1. Tentative validation RPC si infos compl√®tes
      if (personalInfo?.firstName && personalInfo?.lastName) {
        console.log("üîç Tentative validation RPC...");
        const rpcResult = await AnonymousValidationService.validateViaRPC(accessCode, personalInfo);
        if (rpcResult.success) {
          console.log("‚úÖ Validation RPC r√©ussie");
          return rpcResult;
        }
      }

      // 2. Tentative validation anonyme via Edge Function
      console.log("üîç Tentative validation anonyme...");
      const anonymousResult = await AnonymousValidationService.validateCodeAnonymously(accessCode, personalInfo);
      if (anonymousResult.success) {
        console.log("‚úÖ Validation anonyme r√©ussie");
        return anonymousResult;
      }

      // 3. Fallback vers validation classique (si utilisateur connect√©)
      console.log("üîç Fallback validation classique...");
      
      // Tentative code temporaire
      const temporaryResult = await ValidationService.validateTemporaryCode(accessCode, personalInfo);
      if (temporaryResult.success) {
        return temporaryResult;
      }

      // Tentative code fixe (si infos personnelles fournies)
      if (personalInfo?.firstName && personalInfo?.lastName) {
        const fixedResult = await ValidationService.validateFixedCode(accessCode, personalInfo);
        if (fixedResult.success) {
          return fixedResult;
        }
      }

      return {
        success: false,
        error: "Code d'acc√®s invalide ou expir√©. V√©rifiez que le code est correct et qu'il n'a pas expir√©."
      };

    } catch (error: any) {
      console.error("üí• Erreur validation:", error);
      return {
        success: false,
        error: "Erreur technique lors de la validation"
      };
    }
  }

  // ============ GESTION DES CODES ============

  /**
   * Prolonge un code temporaire
   */
  static async extendCode(accessCode: string, additionalDays: number): Promise<CodeGenerationResult> {
    return CodeManagementService.extendCode(accessCode, additionalDays);
  }

  /**
   * R√©voque un code temporaire
   */
  static async revokeCode(accessCode: string): Promise<CodeGenerationResult> {
    return CodeManagementService.revokeCode(accessCode);
  }
}
